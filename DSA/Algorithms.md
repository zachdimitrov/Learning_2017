## Algotithms

- Using Pseudo Code
- Using Flowcharts

### Types of algorithms

#### Sorting and Searching
#### Dynamic programming
#### Graph algorithms
- DFS and BFS traversals
#### Combinatorial algorithms
- Recursive algorithms
#### Other algorithms
- Greedy algorithms
- Computational geometry
- Randomised algorithms
- Generic algorithms

### Algotithm Analisis

#### Predict required resources
#### Running time of algorithms
- total number of operations
- algorithm complexity

### complexity
- Worst Case
- Average Case
- Best Case

#### Types of complexity

complexity | notation | description
-- | -- | --
quadratic | O(1) | Constant number of operations regardless the input Data
logaritmic | O(log n) | Proportional but very small number of operations
linear | O(n) | Number of operations is almost same as elements
linear*log | O(n*log n) | Very often appearing complexity
quadratic | O(n^2) | Proportional to square of elements
qubic | O(n^3) | Proportional to cube of elements
exponential | O(2^n), O(k^n), O(n!) | Too complex - 20 elements -> 1 mln operations
super slow | O(nn) | 3-4 min for 10 operations

#### Multiple variable complexity
- matrices - **n** rows and **k** cols - **n\*k** complexity
#### Polinomial algorithms
- polinomial - n2, n3 + n2, n2 + 2n - slow
- non polinomial - 2n, 3n, nn, n!, nk - slow
#### NP problems
**P -> NP <-> NP complete -> NP hard** classes
- problem is to proove that **P = NP**

#### Analyzing complexity
- for each **for** cycle we add **\*n**
- fibonacci - k*2^n where k is 1.618..

#### Online Task Systems
- bgcoder
- codeforces
- topcoder
- leadcofe
- usaco
